---
layout: default
title: Assignments
---

<h2>Your first activity</h2>

<h3>Create the activity</h3>

Activities are the most important building blocks in Android. They provide the data and wiring required for displaying each screen in your app. A simple rule of thumb is one activity for each screen. Activities provide callback methods to hook into various lifecycle events, e.g. creating and resuming the activity, that you must override.

<ol>
  <li>Create a new activity called 'MessagesActivity' (Java class that extends Activity).</li>
  <li>Override the onCreate(Bundle savedInstanceState) method that will be called when your activity is created.</li>
</ol>

<h3>Create the view</h3>

Now we need to tell the system how to display the UI for the new activity. The UI in Android apps are created using XML layout files. They live in the res/layout folder. Each xml file in this folder will be accessible from java code using <code>R.layout.layout_file_name</code>.

<ol>
  <li>Create the layout <code>activity_messages.xml</code> by right clicking the layout folder and selecting New/Layout resource file.</li>
  <li>Under Root element, choose RelativeLayout.</li>
  <li>Create an TextView view inside the RelativeLayout. The android:layout_width and android:layout_height attributes are required. Most of the time you will be using either match_parent when you want the same width or height as the parent view, or wrap_content when the view should take up only the space it requires in the layout. Choose wrap_content for both for now. Also you should never hard code strings in your app, so in the android:text attribute we will be referencing a string value from another resource file.</li>
  <li>Create a new string in res/values/strings.xml</li>
  <li>Reference this string in your new TextView view with <code>@string/your_string_name</code>. The @ prefix also lets you look up values like other views by @id/your_view_id when you need to reference another element.</li>
  <li>Give the TextView view an id, <code>android:id="@+id/my_text_view"</code>. Notice the + sign after @id. This means create an id for this view instead of referencing an existing id.</li>
  <li>Create another TextView view and set it's text to a another string value. Make the new one appear to the right of the first one, by using android:layout_toRightOf and reference the id of the first TextView.</li>
  <li>Tell MessagesActivity to use this layout by calling <code>setContentView()</code> in <code>onCreate()</code>.</li>
</ol>

<h3>Test the app</h3>

The time has come for you to start the app and see what it looks like, but first we need to specify which activity will be displayed when the app starts. A special file called AndroidManifest.xml contains a declaration of all the app activities, the permissions required (like internet access) and much more.

<ol>
  <li>Open the file 'AndroidManifest.xml' and add and activity element inside the application element.</li>
  <li>Set the name to the MessagesActivity class and give it a descriptive label.</li>
  <li>Add an intent-filter inside the activity element so that the activity responds to intents of the category android.intent.category.LAUNCHER. You can think of intents as broadcast messages with a name and payload that activites can listen for. They can be sent by the system and between activities in your own app. When the system sends an intent to start the app, MessagesActivity will now respond and show itself on screen.
  </li>
  <li>Plug in your phone, hit the debug button in the top menu in Android Studio, choose your phone in the list that appears, wait a few seconds and profit!</li>
</ol>

<code class="xml">
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />

    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
</code>


You will create a twitter-like app that communicates with an HTTP REST API for viewing and creating messages. It is up to you whether you want to focus on GUI polish and interaction, or implement all the functionality in the API.

<h3>API</h3>

<p>The server is at: <a href="http://mobile-course.herokuapp.com">
		http://mobile-course.herokuapp.com</a></p>

<p>
It hosts the following JSON endpoints:
<table class="table table-bordered">
	<thead>
		<tr>
			<th>URL</th>
			<th>HTTP verb</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
	<tr>
		<td><a href="http://mobile-course.herokuapp.com/message">http://mobile-course.herokuapp.com/message</a></td>
		<td>GET</td>
		<td>Retrieves all messages</td>
	</tr>
	<tr>
		<td><a href="http://mobile-course.herokuapp.com/message">http://mobile-course.herokuapp.com/message</a></td>
		<td>POST</td>
		<td>Creates a message(see JSON example below)</td>
	</tr>
	<tr>
		<td><a href="http://mobile-course.herokuapp.com/:id">http://mobile-course.herokuapp.com/message/:id</a></td>
		<td>PUT</td>
		<td>Updates a message</td>
	</tr>
	<tr>
		<td><a href="http://mobile-course.herokuapp.com/:id">http://mobile-course.herokuapp.com/message/:id</a></td>
		<td>DELETE</td>
		<td>Deletes a message</td>
	</tr>
	</tbody>
</table>

<h3>POST example</h3>

<div class="highlight"><pre><code class="javascript"><span class="p">{</span>
	<span class="c1">//Date is not required, but can be fun to manipulate.;)</span>
	<span class="s2">&quot;from&quot;</span><span class="o">:</span><span class="s2">&quot;hinderberg&quot;</span><span class="p">,</span>
	<span class="s2">&quot;message&quot;</span><span class="o">:</span><span class="s2">&quot;You'll Never Walk Alone!:)&quot;</span><span class="p">,</span>
	<span class="s2">&quot;image&quot;</span><span class="o">:</span><span class="s2">&quot;www.url.to.image&quot;</span><span class="p">,</span>
	<span class="s2">&quot;date&quot;</span><span class="o">:</span><span class="s2">&quot;2012-10-18T17:43:48.011Z&quot;</span> 

<span class="p">}</span>
</code></pre></div>

<h3> Retrofit </h3>
If you want to use retrofit, you will need the following gradle dependency:
<code>compile 'com.squareup.retrofit:retrofit:1.6.1'</code>.

If you want to do things manually and need a framework for JSON-parsing, we suggest using Gson.
